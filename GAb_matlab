function [X] = rana (X)
clear all;
close all;
clc;
z = zeros(50 ,3);
arr_crom = randi([0 1], 50, 6);%genera la poblacion en binarios 
xr = bi2de(arr_crom,2);% la pasamos a decimal.

%Ce_cm = [];
Ce_cm = num2cell(z); %convertimos el array en celda.


%obtenemos el valor de aptitud.
xr1 = [];
for ir = 1:length(xr)
    a = xr(ir);
    b = (a/32-1).^(2);   % la funcion fittness para evaluar la aptitud
    xr1 = [xr1,b];
    
end


% es necesario poner los numero binarios en arrays de 6.
n = [];
for lr = 1:50
    for kr = 1:6
        n = [n,arr_crom(lr,kr)];
    end
    
    Ce_cm{lr,1} = n;%agregamos todos los binarios a una array
    n = [];
    Ce_cm{lr,2} = xr(lr);
    Ce_cm{lr,3} = xr1(lr);
end
%disp(Ce_cm)        

%En este punto especifico del programa, ya se cuenta con una celda Ce_cm
%con una columna de los numeros binarios la segunda de su valor decimal y 
%una tercera con su valor de aptitud.



[celda_ord] = ord_insertion(Ce_cm);
disp(celda_ord)
vec_prio = [];
for le = 1:50
    vec_prio = [vec_prio,Ce_cm{le,3}];
end

%es necesario generar una celda donde introducir los 
%valores de mi generacion elit.
za = zeros(50 ,3);
ind_elit = num2cell(za);
AAp = [];
AAAp = [];
for ir = 1:25

[padre1,padre2] =  sel_pad(vec_prio,Ce_cm);

[hijo1,hijo2] = crz_pa(padre1,padre2);
%disp(padre1)
%disp(padre2)
%disp(hijo1)
%disp(hijo2)

[b_1,b_2] = fit_func_elit(padre1,padre2,hijo1,hijo2);
%disp(b_1)
%disp(b_2)
AAp = b_1;
AAAp = b_2;
ind_elit{ir,1} = AAp;
ind_elit{(ir+25),1} = AAAp;
 
AAp = [];
AAAp = [];
end
[celda_com] = aptitud_d(ind_elit);



%en este punto generamos la primera generacion de elit.
aptitud_total = [];
iteraciones = [];
num_int = 0;
for fr = 1:200
    [celda_com] = aptitud_d(ind_elit);
    num_int = num_int + 1;
    iteraciones(fr)= num_int;
    vec_prio = [];
    for le = 1:50
        vec_prio = [vec_prio,celda_com{le,3}];
    end

    [padre1,padre2] =  sel_pad(vec_prio,celda_com);

    [hijo1,hijo2] = crz_pa(padre1,padre2);

    [b_1,b_2] = fit_func_elit(padre1,padre2,hijo1,hijo2);


    AAp = b_1;
    AAAp = b_2;
    ind_elit{ir,1} = AAp;
    ind_elit{(ir+25),1} = AAAp;
 
    AAp = [];
    AAAp = [];
    aptitud_temp = [];
    [celda_com] = aptitud_d(ind_elit);
    for fre = 1 : 50
        aptitud_temp(fre) = celda_com{fre,3};
       % disp(aptitud_temp)
    end    
    sum_aptitud_temp = sum(aptitud_temp);
    aptitud_total(fr) = sum_aptitud_temp/50;
    %disp(aptitud_total)
end
%x = 0:pi/4:2*pi; 
%v = sin(x);

%xq = 0:pi/16:2*pi;
%figure
%vq1 = interp1(x,v,xq);
%plot(x,v,'o',xq,vq1,':.');
%xlim([0 2*pi]);
%title('(Default) Linear Interpolation');

xq = 0:pi/16:80*pi;
vq1 = interp1(iteraciones,aptitud_total,xq);
plot(iteraciones,aptitud_total,'*',xq,vq1,':.');

X = celda_com;































%Secci[on de funciones necesarias para correr el programa principal
%funci[on de ordenamiento

function[celda_ord] = ord_insertion(Ce_cm)
%Ce_cm = celda;
for ls = 1:50
    d = ls;
    while((d > 1) && (Ce_cm{d,3}) > (Ce_cm{d-1,3}))
        %Accomadar aptitud.
        var_temp = Ce_cm{d,3};
        Ce_cm{d,3} = Ce_cm{d-1,3};
        Ce_cm{d-1,3} = var_temp;
        %d = d-1;
        %acomadar valor decimial, de acuerdo a aptitud. 
        var_temp1 = Ce_cm{d,2};
        Ce_cm{d,2} = Ce_cm{d-1,2};
        Ce_cm{d-1,2} = var_temp1;
        %acomodar valores binarios, de acuerdo a aptitud. 
        var_temp2 = Ce_cm{d,1};
        Ce_cm{d,1} = Ce_cm{d-1,1};
        Ce_cm{d-1,1} = var_temp2;
        
        d = d-1;
        
    end
end
celda_ord= Ce_cm;
end






%funci[on Roulette Wheel selection


function [index] = my_own_RWS(vec_prio)
% generamos la probabilidad de que sean seleccionados, esta aumenta 
%dependiendo de su fitness
%sum_of_fitness = 10
%previous_probability = 0.0

%[1] = previous_probability + (fitness / sum_of_fitness) = 0.0 + (1 / 10) = 0.1
%previous_probability = 0.1
%disp(x)
x = vec_prio;
xb = flipud(x); %invertimos los valores 
Xpro = [];
Xpro = xb/sum(xb);   %Generamos todo la matriz con los resultados (fitness / sum_of_fitness)


%Generamos la probabilidad de ser seleccionado la suma de pre_pro + (fit/sum)
proba = [];
prev_proba = 0;
for km = 1:length(x)
    proba(km) = prev_proba + Xpro(km);
    prev_proba = proba(km);
end
%disp(proba)
%Escogemos al asar el numero en index que necesitamos.
xbp = flipud(proba);
num_rand = rand;
%disp(i_rand)
for ksr = 1:length(xbp)
    if num_rand < xbp(ksr)
        index = ksr;
        return
    end
end

%te da una ubicacion por indice de el numero seleccionado.

   
end







%funcion para seleccionar padres.
function [padre1,padre2] =  sel_pad(vec_prio,celda)
 Ce_cmp = celda;       
padre1 = [];
padre2 = [];
for rl = 1:2
    if rl ==1
    [index] = my_own_RWS(vec_prio);
    %disp(index)
    padre1 = [padre1,Ce_cmp{index,1}];
    end
    if rl ==2
        [index] = my_own_RWS(vec_prio);
        %disp(index)
        padre2 = [padre2,Ce_cmp{index,1}];
    end
end


end    















%la funcion que genera a los hijos.
% la funcion que hace el cruce de padres
function[hijo1,hijo2] = crz_pa(padre1,padre2)
%es necesario concatenar padre 1 y padre 2;
padres = cat(6,padre1,padre2);
%disp(padres)
hijo1 =[];
hijo2= [];

for er = 1:3
    hijo1 = [hijo1,padres(er)];
    hijo2 = [hijo2,padres(er+3)];
end

for or = 1:3
    hijo1 = [hijo1,padres(or+9)];
    hijo2 = [hijo2, padres(or+6)];
end    

%disp(padres)
%disp(hijo1)
%disp(hijo2)
       
        
end        













%en la siguiente funci[on aplicamos elitismo buscando los individuos mas
%aptos.

function [b_1,b_2] = fit_func_elit(padre1,padre2,hijo1,hijo2)
 
%padre1=[1,1,1,0,0,1];
%padre2=[0,1,1,1,1,1];
%hijo1=[1,1,1,1,1,1];
%hijo2=[0,0,1,0,1,1];

    
%compara aptitud de padres he hijos
%para evaluar el mejor.

%Es necesario convertir en celda, para cuando apliquemso elitismo
%podamos regresar los dos mas aptos en valor binario 
Ce_f = [0,0,0;0,0,0;0,0,0;0,0,0];
Ce_f = num2cell(Ce_f);
%disp(Ce_f)

%metemos los padres he hijos e forma binaria en la 
%primera columna
Ce_f{1,1}=padre1;
Ce_f{2,1}=padre2;
Ce_f{3,1}=hijo1;
Ce_f{4,1}=hijo2;
%disp(Ce_f)
%convertir a decimal
padre1 = bi2de(padre1,2);
padre2 = bi2de(padre2,2);
hijo1 = bi2de(hijo1,2); 
hijo2 = bi2de(hijo2,2);
%metemos su valor en decimal en la segunda columna
Ce_f{1,2}=padre1;
Ce_f{2,2}=padre2;
Ce_f{3,2}=hijo1;
Ce_f{4,2}=hijo2;

%disp(padre1)
%disp(padre2)
%disp(hijo1)
%disp(hijo2)
array = cat(4,padre1,padre2,hijo1,hijo2);
%disp(array)
%obtenemos el valor de aptitud.
aptitud_arr = [];
for irs = 1:length(array)
    as = array(irs);
    bs = (as/32-1).^(2);   % la funcion fittness para evaluar la aptitud
    aptitud_arr = [aptitud_arr,bs]; 
end
%disp(aptitud_arr)

% es necesario aplicar el algoritmo de ordenamiento.
%pero primero es necesario asignar un lugar en la celda

for klr = 1:length(aptitud_arr)
    Ce_f{klr,3} = aptitud_arr(klr);
end
%disp(Ce_f)


% esta lista la celda con tres columnas, valor en binario, decimal, aptitud
%aplicamos ordenamiento para regresar los dos mas aptos.

for lse = 1:4
    de = lse;
    while((de > 1) && (Ce_f{de,3}) > (Ce_f{de-1,3}))
        %Accomadar aptitud.
        var_tempe = Ce_f{de,3};
        Ce_f{de,3} = Ce_f{de-1,3};
        Ce_f{de-1,3} = var_tempe;
        %d = d-1;
        %acomadar valor decimial, de acuerdo a aptitud. 
        var_temp1e = Ce_f{de,2};
        Ce_f{de,2} = Ce_f{de-1,2};
        Ce_f{de-1,2} = var_temp1e;
        %acomodar valores binarios, de acuerdo a aptitud. 
        var_temp2e = Ce_f{de,1};
        Ce_f{de,1} = Ce_f{de-1,1};
        Ce_f{de-1,1} = var_temp2e;
        
        de = de-1;
        
    end
end
%nos entrega una variable acomodada por aptitud
%entonces regresamos los dos valores mas aptos.
%disp(Ce_f)
b_1 = Ce_f{1,1};
b_2 = Ce_f{2,1};


end   
        








%funcion apara convertir de binario a decimal, y dar el valor de aptitud

function[celda_com] = aptitud_d(ind_elit)

    
for tr =1:length(ind_elit)    
    ind_elit{tr,2} = bi2de(ind_elit{tr,1},2);   
end

%celda_com=ind_elit;

%obtenemos el valor de aptitud.
%xr1 = [];
for tir = 1:length(ind_elit)
   
    ar = ind_elit{tir,2};
    br = (ar/32-1).^(2);   % la funcion fittness para evaluar la aptitud
    ind_elit{tir,3} = br;
    
end


celda_com=ind_elit;

end

end
